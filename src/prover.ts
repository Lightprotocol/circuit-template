const snarkjs = require('snarkjs');
const fs = require('fs');
const { unstringifyBigInts, leInt2Buff, leBuff2int } = require('ffjavascript').utils;
import { ZkBattleship as IDL } from '../zk-battleship/target/types/zk_battleship';

export namespace Generics {

	// Recursive generic type parser till dimension = 4 i.e. for
	// { array: [{ array: [{ array: [{ array: ["u8", 2] }, 3] }, 4] }, 5] } => string[][][][] 	
	export type ConvertArray<T> = T extends { array: infer U }
		? U extends [{ array: infer K }, number]
			? Array<ConvertArray<{ array: K }>>
			: U extends ["u8", number]
				? Array<string>
				: never
		: T extends "u8"
			? string
			: never;
	
	// type example for mapped generic
	type CircuitObject = IDL["accounts"][2]["type"]["fields"][number];
		
	// create a mapped type combing name as key and type as property
	type MappedCircuitObject = {
		[Key in CircuitObject['name']]: Extract<CircuitObject, { name: Key }>['type'];
	};

	// parse Rust types into TS
	type CircuitInputsObject<T> = {
		[Property in keyof T] : ConvertArray<T[Property]>
	}

	//let proofTypes: CircuitInputsObject<MappedCircuitObject>

	export type Accounts = IDL["accounts"][number];

	export type FetchZKAccounts<T> = T extends Accounts 
		? T["name"] extends `zK${infer _}` 
			? T
			: never
		: never

	export type ZKAccounts = FetchZKAccounts<Accounts>;

	export type FetchProofAccounts<T> = T extends ZKAccounts
		? T["name"] extends `${infer _}Proof${infer _}` 
			? T
			: never
		: never
	export type ZKProofAccounts = FetchProofAccounts<ZKAccounts>
	
	export type FetchPublicInAccounts<T> = T extends ZKAccounts
		? T["name"] extends `${infer _}Public${infer _}` 
			? T
			: never
		: never
	export type ZKPublicInAccounts = FetchPublicInAccounts<ZKAccounts>
}

export type proofData = {
    pi_a: string[];
    pi_b: string[][];
    pi_c: string[];
    protocol: string;
    curve: string;
}

export type vKeyData = {
    protocol: string;
    curve: string;
    nPublic: number;
    vk_alpha_1: string[];
    vk_beta_2: string[][];
    vk_gamma_2: string[][];
    vk_delta_2: string[][];
    vk_alphabeta_12: ArrayConstructor[][][];
    IC: string[][];
}

// it is possible to read the idl file and enter it in the prover class constructor
// or provide the path and read it inside of the class
export class Prover {

	public idl: IDL; 
	public idlPath: string;
    public proofInputs;
    public publicInputs: string[];
	public vKey: vKeyData;
    public proof: proofData;

	constructor( 
		idlPath: string
	) {
		this.idl = JSON.parse(fs.readFileSync(idlPath));;
	}

	async addProofInputs(proofInputs: any, circuitName: string) {
		
		
		const circuitIdlObject = this.idl.accounts.find((account) => account.name === `zK${circuitName}ProofInputs`);

		if (!circuitIdlObject) {
			throw new Error(`${`zK${circuitName}ProofInputs`} does not exist in anchor idl`);
		}
		
		const fieldNames = circuitIdlObject.type.fields.map((field: { name: string }) => field.name);
		const inputKeys = [];

		fieldNames.forEach((fieldName: string) => {
			inputKeys.push(fieldName);
		});

		let inputsObject = {};

		inputKeys.forEach((key) => {
			inputsObject[key] = proofInputs[key];
			if(!inputsObject[key])
				throw new Error(`Property ${key.toString()} undefined`);
		})

		this.proofInputs = {...inputsObject};
		
		
	
	}

	async fullProve(input: any, wasmFilePath: string, zkeyFilePath: string) {

		const { proof, publicSignals } = await snarkjs.groth16.fullProve(
			input, 
			wasmFilePath,
			zkeyFilePath
		);

		this.publicInputs = publicSignals;
		this.proof = proof;
	}

	async getVkey(zkeyFilePath: string) {
		const vKey = await snarkjs.zKey.exportVerificationKey(zkeyFilePath);
		this.vKey = vKey;
	}

	async verify(zkeyFilePath: string, proof?: {proofA, proofB, proofC}): Promise<boolean> {

		// verifies the proof generated by this class or a passed in proof
		await this.getVkey(zkeyFilePath);
		const res = await snarkjs.groth16.verify(
			this.vKey, 
			this.publicInputs, 
			this.proof
		);
		return res
	}
	
    parseProofToBytesArray(data: any): {
		proofA: number[], 
		proofB: number[][],
		proofC: number[]
	} {
		var mydata = JSON.parse(data.toString());

		for (var i in mydata) {
			if (i == "pi_a" || i == "pi_c") {
				for (var j in mydata[i]) {
				mydata[i][j] = Array.from(
					leInt2Buff(unstringifyBigInts(mydata[i][j]), 32),
				).reverse();
				}
			} else if (i == "pi_b") {
				for (var j in mydata[i]) {
					for (var z in mydata[i][j]) {
						mydata[i][j][z] = Array.from(
						leInt2Buff(unstringifyBigInts(mydata[i][j][z]), 32),
						);
					}
				}
			}
		}
	
		return {
			proofA: [mydata.pi_a[0], mydata.pi_a[1]].flat(),
			proofB: [
				mydata.pi_b[0].flat().reverse(),
				mydata.pi_b[1].flat().reverse(),
			].flat(),
			proofC: [mydata.pi_c[0], mydata.pi_c[1]].flat()
		};
	}

	// mainly used to parse the public signals of groth16 fullProve
	parseToBytesArray(publicSignals: Array<string>): number[][] {
      
		var publicInputsBytes = new Array<Array<number>>();
		for (var i in publicSignals) {
			let ref: Array<number> = Array.from([
			...leInt2Buff(unstringifyBigInts(publicSignals[i]), 32),
			]).reverse();
			publicInputsBytes.push(ref);
		}
		
		return publicInputsBytes
	}

	async fullProveAndParse(input: any, wasmFilePath: string, zkeyFilePath: string) {

		await this.fullProve(input, wasmFilePath, zkeyFilePath);
		let parsedPublicInputsObj = this.parseToBytesArray(this.publicInputs);
		let parsedProofObj = this.parseProofToBytesArray(this.proof);

		return { proof: parsedProofObj, publicInputs: parsedPublicInputsObj }
	}

}


/* type KeyValue = {
	[key: string]: any;
};

export function pickProofInputsAccount<T extends KeyValue>(
	obj: T, 
	accounts: IDL["accounts"], 
	circuitName: string
): Partial<KeyValue> {
	const circuitIdlObject = accounts.find((account) => account.name === `zK${circuitName}ProofInputs`);

	if (!circuitIdlObject) {
		throw new Error(`${`zK${circuitName}ProofInputs`} does not exist in anchor idl`);
	}
	
	const fieldNames = circuitIdlObject.type.fields.map((field: { name: string }) => field.name);
	const inputKeys: (keyof T)[] = [];

	fieldNames.forEach((fieldName: string) => {
		inputKeys.push(fieldName);
	});

	let inputsObject: Partial<T> = {};

	inputKeys.forEach((key) => {
		inputsObject[key] = obj[key];
		if(!inputsObject[key])
			throw new Error(`Property ${key.toString()} undefined`);
	})

	return inputsObject;
}
 */
/* const obj = {
	testInput1: 1, 
	testInput2: 2, 
	rndOtherStuff: {s:2342}, 
	o: [2,2,new BN(2)]
};*/
// const prover = new Prover('../zk-battleship/target/idl/zk_battleship.json')
// let data = pickFields(obj, idl.accounts, "utxoAppData");


